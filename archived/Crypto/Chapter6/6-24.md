## 利用斐波那契数列周期重复性爆破

题目代码如下

```python
from Crypto.Util.number import *
from gmpy2 import next_prime
from functools import reduce
from secret import flag


def F(x):
    if x == 1 or x == 2:
        return 1
    return F(x-1)+F(x-2)


n = reduce(lambda a, b: a*b, [getPrime(4) for _ in range(4)])
r = getRandomNBitInteger(67)
S = sum([F(i) % n for i in range(r)])
p = next_prime(S**16)
q = getPrime(p.bit_length())
m = bytes_to_long(flag)
c = pow(m, 65537, p*q)

print("r =", r)
print("n =", n)
print("c =", c)
print("N =", p*q)
```

现在分析代码

定义了一个斐波那契数列

```python
def F(x):
    if x == 1 or x == 2:
        return 1
    # 递归定义，计算量巨大，但由于模运算，实际计算只需在一个周期内完成
    return F(x-1) + F(x-2)
```

斐波那契数列是一个**递推数列**，它的核心规则是：**从第三项起，数列中的每一项都等于前两项之和**
$$
\begin{aligned}
&F_n\ =\ F_{n-1}\ +\ F_{n-2}\ (n \geq 3)
\end{aligned}
$$
在 CTF 和数论领域，斐波那契数列的**模运算性质**至关重要：

Pisano 周期

- **定义：** 斐波那契数列对任何正整数 n 取模后，都会变成一个**循环数列**。这个循环的长度就被称为 **Pisano 周期**，记作
  $$
  \begin{aligned}
  &\pi(n)
  \end{aligned}
  $$

小模数 n 的生成

```python
# 2. 小模数 n 的生成
# 生成 4 个 4-bit 的小素数（p_i <= 15）
# n 是这四个小素数的乘积
# n 的大小约为 16 bits (n <= 15^4 = 50625)
n = reduce(lambda a, b: a*b, [getPrime(4) for _ in range(4)])
```

巨大的求和上限 r

```python
# 3. 巨大的求和上限 r
# r 是一个 67-bit 的大整数 (r 约等于 2^67)
# 注意：r 是计算 S 的唯一输入，且 r 已经泄露给我们
r = getRandomNBitInteger(67)
```

S 的计算

```python
# 4. 关键泄露信息 S 的计算 (S是 p 的基础)
# S 是前 r 个斐波那契数在模 n 下的和：S = Sum_{i=0}^{r-1} (F(i) mod n)
S = sum([F(i) % n for i in range(r)])
```

生成巨大的素数 p

```python
# 5. 生成巨大的素数 p
# p 是 S^16 之后的第一个素数
# S 的大小约为 r * n (约 2^67 * 2^16 = 2^83)
# p 的大小约为 (2^83)^16 = 2^1328 bits
p = next_prime(S**16)
```

生成素数 q

```python
# 6. 生成素数 q
# q 是一个与 p 相同长度的素数 (q 约 1328 bits)
q = getPrime(p.bit_length())
```

首先要求出 p -> S -> r 这个顺序

先看 S 的计算方式
$$
\begin{aligned}
&S\ =\ \sum_{i-0}^{r-1}{F((i)\ \ (mod\ n))}
\end{aligned}
$$
求和次数 r 太大，但是，求和时使用的模数 **n 却非常小**（不到 65536）

这是整个解题的关键步骤。我们不能循环 r 次，但 n 很小，所以我们要找规律

**Pisano 周期（重复的舞蹈）**

当斐波那契数列对一个小数字 n 取模时，它的结果会不断重复，形成一个**循环**。这个循环的长度就是 **Pisano 周期 T**

- 斐波那契数列 mod n 就像一个**舞者**在一个很小的圆形舞台（模数 n）上跳舞。它跳了一段时间后，姿势和位置一定会回到起点 (1, 1)
- **周期 T** 就是这支舞完整跳完一次所需要的步数

通过脚本实现

```python
a, b = 1, 1
while True:
    a, b = b, (a + b) % n # 找到下一步的舞步
    if a == 1 and b == 1: # 检查是否回到起点
        T = period = len(fibs) # 记录步数 T
        break
```

因为 n 很小，这个循环很快就能结束，我们得到了周期 T 和跳一圈舞的总得分 Sum_{cycle}

现在我们有了舞蹈的规律，就可以计算 r 步的总得分 S：

- **完整周期数 k：** k = r // T （看看 r 步能跳多少次完整的舞）
- **剩余步数 rem：** rem = r \% T （最后多出来没跳完的几步）

$$
\begin{aligned}
&S\ =\ (完整次数\ k\ *\ 一圈的总得分\ Sum_{cycle})\ +\ (剩余几步的得分\ Sum_{cycle})
\end{aligned}
$$

这一步就将天文数字 r 转换成了一个可计算的公式，得到了我们想要的秘密蓝图 S

| **脚本代码**              | **作用**                                                     | **简单理解** |
| ------------------------- | ------------------------------------------------------------ | ------------ |
| `p = next_prime(S ** 16)` | **计算第一个秘密零件 p。** 严格按照题目的公式，找到 S^{16} 之后的第一个素数 |              |
| `q = N // p`              | **计算第二个秘密零件 q。** N 是 p 和 q 的乘积，所以 q = N / p |              |
| `phi = (p - 1) * (q - 1)` | **计算制造蓝图 \phi(N)**                                     |              |
| `d = inverse(65537, phi)` | **计算万能钥匙 d。** `inverse` 是求一个数在 \pmod{phi} 世界里的“倒数” |              |
| `m = pow(c, d, N)`        | **解密！** 使用万能钥匙 d 打开保险箱 N 中的密文 c            |              |
| `long_to_bytes(m)`        | 将解密得到的数字 m 转换回 Flag 文本                          |              |

完整代码如下

```python
from Crypto.Util.number import *
import gmpy2

# ==========================================
# 1. 在此填入题目给出的参数 (从你的题目输出中复制)
# ==========================================
r = 6799657976717333  # 题目给出的 r (67-bit integer)
n = 34969  # 题目给出的 n (小整数，约 16-bit)
c = 182306974283951620352146026941583994848813143690343545292100780435573376889099600153592983212384957591086328477660614034391593564733860826251499298995355977799109267846836211477797049861348446512705981010295182077777939692478140339301301250656211795668782349225298841295102744088295274299888068087536135862146848855194234931032258224223054120694400807261402442809227521150204434199401928373883267697928229945582110688115412960868921538084717338343966490113059627708880297277412143561561837953806960309840302665509500602335832680764801782789278492075478763944213005349707521471401389317139473794212210077629296628421658105048387207038261321205  # 题目给出的密文 c
N = 1885611999537620305525377668936000019248252379006235038175895811710218489750248037027959751027236326639084060685909621893589756343903429224938045802850975926055076789137326688384533999739909152386986919824268841500802585809839133132715892685629871188263336038221503698167753853207939360629026179572549702198037779413041272313618794196167670066872427987596564652249864272782397242041014605617282098654595635031878004275878165728021995744626212185694275937448739806439006047047376363093018124169182873374456718929377731991273039952515054850718253257895996999907977029169396644305213162133388169761391593110121229266422245167572929912914529689341  # 题目给出的公钥 N


# ==========================================
# 2. 核心函数：寻找 Pisano 周期并计算周期和
#    对应思路 2 的优化版：直接在 Python 中实现
# ==========================================
def get_pisano_info(n):
    # 斐波那契数列缓存，用于计算余数部分的和
    fibs = [1, 1]

    # 寻找周期：暴力迭代直到再次出现 "1, 1"
    # 因为 n 很小，这个循环会很快结束
    a, b = 1, 1
    period = 0

    while True:
        # 下一项 F(i) = F(i-1) + F(i-2)
        a, b = b, (a + b) % n
        fibs.append(b)

        # 检查是否回到了起点 (1, 1)
        # 注意：现在的 b 是新的一项，a 是上一项
        if a == 1 and b == 1:
            # 找到了循环节！
            # 此时 fibs 最后两个是 1, 1，属于下一个周期的开始，要去掉
            fibs.pop()
            fibs.pop()
            period = len(fibs)
            break

    period_sum = sum(fibs)
    return period, period_sum, fibs


print(f"[*] Analyzing Pisano period for n = {n}...")
period, period_sum, fibs = get_pisano_info(n)
print(f"[+] Period found: T = {period}")
print(f"[+] Sum of one period: {period_sum}")

# ==========================================
# 3. 计算 S
#    利用公式：S = (完整周期的次数 * 周期和) + (剩余部分的和)
# ==========================================
k = r // period  # 完整的周期数
rem = r % period  # 剩余的项数

# 剩余部分的和 = 前 rem 项之和
rem_sum = sum(fibs[:rem])

# 计算最终的 S (注意题目中 S 是模 n 后求和，不需要再对 S 取模)
S = k * period_sum + rem_sum
print(f"[+] Calculated S = {S}")

# ==========================================
# 4. 恢复 RSA 密钥 p, q
#    题目逻辑：p = next_prime(S**16)
# ==========================================
# 注意 S**16 很大，需要用 gmpy2 处理大数运算
base_p = gmpy2.mpz(S) ** 16
p = int(gmpy2.next_prime(base_p))

# 验证 p 是否正确
if N % p == 0:
    print("[+] Successfully recovered p!")
    q = N // p
else:
    print("[-] Failed to recover p. Check parameters.")
    exit()

# ==========================================
# 5. 标准 RSA 解密
# ==========================================
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)

m = pow(c, d, N)
flag = long_to_bytes(m)

print("\n--------------------------------------------------")
print("Flag:", flag.decode())
print("--------------------------------------------------")
```

