## 利用 p 信息泄露 GCD 攻击

解题技巧先放前面：

1. **识别 GCD 攻击模式：**看到泄露信息 hint = m^17 (mod p)，必须立刻联想到 p 是 (m^17 - hint) 的因子

```python
from Crypto.Util.number import *
from secret import flag # 目标明文

# 1. 初始化和密钥生成
m = bytes_to_long(flag)  # 将 Flag 转换为巨大的整数 m
p = getPrime(1024)       # 生成第一个秘密素数 p (1024 bits)
q = getPrime(1024)       # 生成第二个秘密素数 q (1024 bits)
n = p * q                # RSA 模数 N (2048 bits，安全标准)

# 2. 核心漏洞：Hint 的泄露
# 提示 H 是明文 m 以极小的指数 17 对素数 p 取模的结果。
# 数学关系：hint ≡ m^17 (mod p)
# 这意味着 p 整除 (m^17 - hint)
hint = pow(m, 17, p)

# 3. 标准 RSA 加密
e = 65537                # 公钥指数 e (最常用的 Fermat 素数)
c = pow(m, e, n)         # 密文 c ≡ m^e (mod n)

# 4. 泄露给攻击者的信息
print("n =", n)          # 公钥模数 N (2048-bit)
print("e =", e)          # 公钥指数
print("c =", c)          # 密文
print("hint =", hint)    # 泄露信息 H (m^17 mod p)
```

我们从题目提供的两个基本关系开始：
$$
\begin{aligned}
&1:\ x\ =\ 11\ *\ d\ +\ 7\ *\ \phi(n)\\\\
&2:\ e\ *\ d\ \equiv 1\ (mod\ \ {\phi(n)})\\\\
&将\ RSA\ 关系转化为代数等式，引入一个未知整数\ r\\\\
&e\ *\ d\ =\ 1\ +\ r\ *\ \phi(n)
\end{aligned}
$$
我们的目标是消除未知数 d。最有效的方法是将**等式 1** 的两侧都乘以已知的公钥 e，从而引入 e * d 项，方便进行替换

将**等式 1** 两侧同乘 e：
$$
\begin{aligned}
&3:\ x\ *\ e=\ 11\ *\ (e\ *\ d)+\ 7\ *\ e\ *\phi(n)
\end{aligned}
$$
现在，我们将**等式 2** 代入**等式 3** 中的 (e * d) 项：
$$
\begin{aligned}
&3:\ x\ *\ e=\ 11\ *\ (1\ +\ r\ *\ \phi(n))+\ 7\ *\ e\ *\phi(n)
\end{aligned}
$$
现在，等式中已经成功消除了 d。我们进行代数整理，将所有含欧拉函数 n 的项归类，常数项移到左侧
$$
\begin{aligned}
&x\ *\ e=\ 11\ +\ 11\ *\ r\ *\ \phi(n)+\ 7\ *\ e\ *\phi(n)\\\\
&x\ *\ e\ -\ 11\ =\ 11\ *\ r\ *\ \phi(n)+\ 7\ *\ e\ *\phi(n)\\\\
&x\ *\ e\ -\ 11\ =\ (11\ *\ r\ +\ 7\ *\ e)\ *\phi(n)\\\\
&\phi(n)\ =\ \frac{x*e-11}{11*r+7*e}\\\\
\end{aligned}
$$
这个方程中，唯一剩下的未知数是整数 r

由于欧拉函数 n 必须是一个巨大的**整数**（通常 2048 位），因此分子必须能够被分母**整除**

所以直接爆破破解 r

```python
from Crypto.Util.number import *
import gmpy2
import sys

# =========================================================
# 步骤 1: 替换为题目中泄露的参数
# IMPORTANT: 请将这里的占位符替换为你实际的 CTF 数据！
# =========================================================
N = 15321211041844905603734344178124947500324300419514650914959277216026081094496518094622195813971694335738777589926626969243883848477814650916143749322154944235584863085124154540941941026813506509060939499627059712020664731558566028207969260861863294704292014958955493668692256998253634012942569080200336487172402729072437050952572508561453302097971258470685521456512378089846772560530301852104802168974905937732653119166440832834381675710869396094149006807933529429939569477709674581421481769103309376717894952118650888932952440197471338958967318775671821835706884032860123711415773758546392549257375305940969423099611  # RSA 模数 n
E = 65537  # 公钥指数 e (通常是 65537)
C = 14896093236493033914781929755936872928003725648997746598164823180134348743474984136539422027221313199599273430548738399424773586673404519182726589878322104929749149555906399158136445184378100079558203687049497943904275695897824656260657349522646553949766831267321006314984113971129230701131171378457086851261467999754137290017989201512492586108768533159551545321805463224339252886492732021354821330371600069958523522302729848548167244423902572054475396534469987383265867036041513161170273368613864180696427386890714264902686976581317435011139081192227958859641684254938165261747405568369502852705979424383731908971282  # 密文 c
X = 265060901898485540806769085700708185460124724747068797929982044073895401490880169847709049380530156090772787935089173201664711759633269693627724735457902114209008145932150728406880988293457762401679305297063608204632708505031098047582175011825482347052645324085149631658741807382378778694666759557421043250548432429798543553950625554307402164142007388940921309688918410535907564996075660231557340541491155676279511654970843992008027830570227549010293790074386638365293013298327534604995316180405779571245069623638693068707267840181413082202552862853411080755107836252852929279422343700808788459217261282790226013328915  # 泄露信息 x (x = 11*d + 7*phi(n))


# 我们可以从 r=1 开始，因为 r 必须是正整数
R_MAX = 100000


# =========================================================
# 步骤 2: 核心解题函数 - 枚举 r 求解 phi(n)
# =========================================================

def solve_modified_rsa(N, E, C, X, R_MAX):
    """
    根据公式 phi(n) = (X*E - 11) / (11*r + 7*E) 枚举 r，
    并验证结果是否为合法的 phi(n)。
    """

    # 公式分子 C_NUM = X*E - 11
    C_NUM = X * E - 11

    print(f"[*] 开始枚举 r (r_max={R_MAX})...")

    # r 必须为正整数
    for r in range(1, R_MAX + 1):
        # 公式分母 D_DEN = 11*r + 7*E
        D_DEN = 11 * r + 7 * E

        # 1. 整除性检查：判断分子是否能被分母整除
        if C_NUM % D_DEN == 0:

            # 找到潜在的 phi(n)
            phi_n = C_NUM // D_DEN
            print(f"[+] 找到潜在的 phi(n) 候选项 (r={r})")

            # 2. 合理性检查：phi(n) 必须小于 N
            if phi_n >= N:
                # 理论上不可能，如果出现说明数据有误，或 r_max 设置太小
                continue

            # 3. RSA 约束检查：判断 phi(n) 是否能用于分解 N
            # 我们知道：p + q = N - phi(n) + 1
            # 设 S = p + q
            S = N - phi_n + 1

            # 根据韦达定理，p, q 是二次方程 X^2 - S*X + N = 0 的根
            # 判别式 D = S^2 - 4*N 必须是一个完全平方数 (Perfect Square)
            D = S * S - 4 * N

            # 使用 gmpy2 检查 D 是否为完全平方数
            if gmpy2.is_square(D):
                print(f"[!!!] 成功找到正确的 phi(n)!")
                print(f"[!] r = {r}")
                print(f"[!] phi(n) = {phi_n}")

                # 4. 最终解密

                # 计算私钥 d = E^(-1) mod phi(n)
                d = inverse(E, phi_n)

                # 解密明文 m = C^d mod N
                m = pow(C, d, N)

                flag = long_to_bytes(m)

                print("\n==============================================")
                print(f"p + q = {S}")
                print(f"Private Key d = {d}")
                print(f"Decrypted Flag: {flag.decode()}")
                print("==============================================")
                return True  # 退出函数

    print("[-] 未能在设定的 R_MAX 范围内找到有效的 phi(n)，请尝试增大 R_MAX 或检查输入数据。")
    return False


if __name__ == "__main__":
    if N == ...:
        print("错误：请先在脚本顶部替换 N, C, X 的占位符！")
        sys.exit(1)

    solve_modified_rsa(N, E, C, X, R_MAX)
```

