## 动态加载器提权

**Linux 动态加载器**

当一个动态链接的程序被执行时：

1. 内核加载 ELF 可执行文件
2. 内核发现它是动态链接的，于是不直接跳转到 `main()`，而是转而先执行动态链接器（例如 `/lib64/ld-linux-x86-64.so.2`）
3. 动态链接器会解析 ELF 的 `.interp` 段，加载所有依赖的 `.so`，执行符号重定位，然后跳转到用户程序的入口点

动态加载器本身是安全的，但以下机制可能被攻击者利用来实现**本地提权**：

**✅ 1. 环境变量劫持（LD_ 系列）**

Linux 动态链接器在执行过程中会解析多个环境变量，如：

| 环境变量          | 描述                           |
| ----------------- | ------------------------------ |
| `LD_PRELOAD`      | 指定要预先加载的共享库路径。   |
| `LD_LIBRARY_PATH` | 指定额外搜索共享库路径。       |
| `LD_AUDIT`        | 指定审计库，用于拦截函数调用。 |

**前提**：动态链接程序，且不是 setuid 程序（对 setuid 程序，这些变量通常被忽略）

**提权利用**：

- 若存在一个以 root 权限执行的 **非 setuid 程序**（如某些 misconfigured 的守护进程），攻击者可以通过篡改 `LD_PRELOAD` 来注入自己的 `.so` 以执行任意代码

**✅ 2. 利用 SUID 可执行程序中的加载器行为**

利用方式一：**自定义的动态加载器**

某些发行版/环境中允许自定义 `.interp` 段，比如将其指向攻击者自编译的 `ld-linux.so`：

```bash
# 修改 interp 段
patchelf --set-interpreter ./evil-ld.so.2 ./suid-binary
```

若目标程序是 SUID 且未做强校验，则攻击者可借此执行自己的加载器，从而控制整个加载过程并提权

> **注意**：多数现代系统对此有保护，只有当目标程序是用户自己编译的情况下才可能实现该攻击

利用方式二：**伪造共享库路径**

```bash
# 创建 SUID 程序运行所需的共享库名称
echo 'int init() { setuid(0); system("/bin/bash"); return 0; }' > exploit.c
gcc -shared -fPIC exploit.c -o libmylib.so

# 设置 LD_LIBRARY_PATH 并运行目标程序
LD_LIBRARY_PATH=. ./vuln-suid-binary
```

若 SUID 程序在不安全的路径下寻找 `.so`，可以被替换

蚁剑连接出题人给出的 WebShell

![](https://pic1.imgdb.cn/item/6881dfc358cb8da5c8d4ed36.png)

`ldd` 用于显示一个可执行文件或共享库所依赖的共享库（即动态链接库）

![](https://pic1.imgdb.cn/item/6881e00458cb8da5c8d4ee1b.png)

这样的话只要确认下 `ldd` 中动态库是否具备执行权限，是一个突破口

发现 `/lib64/ld-linux-x86-64.so.2` 具有执行权限

![](https://pic1.imgdb.cn/item/6881e06458cb8da5c8d4efd8.png)

利用这个文件执行拿到 flag

![](https://pic1.imgdb.cn/item/6881e0b658cb8da5c8d4f248.png)
