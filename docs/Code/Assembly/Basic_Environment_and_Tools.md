

# 基础环境与工具

在真正开始阅读和分析汇编代码之前，我们需要先认识一些“**工具**”。  
不用担心，这一步并不要求你立刻成为“命令行高手”，我们更关心的是——**这些工具各自是做什么的、什么时候会用到它们**。

你可以把这一章理解为：  
> 🧰 **进入汇编世界前的工具箱说明书**

---

## 为什么需要这些工具？

和 Python 直接运行 `.py` 文件、C/C++ 一键编译运行不同，  
汇编语言更加“贴近硬件”，因此需要**多几个步骤**才能真正跑起来。

一个最基础的流程通常是：

```
汇编代码 → 汇编器 → 目标文件 → 链接器 → 可执行程序
```

听起来有点复杂，但请记住一句话就够了：

> 👉 **工具帮你干活，你只需要知道它们各自负责哪一段。**

---

## 汇编语言的基本工作流程

在正式介绍工具之前，我们先用一句“人话”解释整个过程：

1. ✍️ 你写的是 **汇编代码**（人类可读）
2. ⚙️ 汇编器把它翻译成 **机器指令**
3. 🔗 链接器把零散的指令拼成一个完整程序
4. ▶️ 操作系统加载程序并交给 CPU 执行

在 CTF 中，我们**很少从第 1 步开始写代码**，  
更多时候是从第 3、4 步“倒着看”。

---

## 汇编器（Assembler）

### 它是做什么的？

**汇编器**的作用只有一个：

> 🛠️ 把 `.asm` 汇编代码，翻译成 CPU 能看懂的机器指令

它不会理解“程序逻辑”，只会**忠实地翻译指令**。

---

### 常见汇编器

#### 🔹 NASM（推荐）

- 常用于 Linux / CTF 环境
- 语法清晰、资料多
- 非常适合初学者

```text
nasm example.asm -f elf64
```

你现在不需要记住这条命令，

只要知道：**NASM 是汇编世界里的“翻译官”**。

---


#### 🔹 MASM

- Windows 平台常见

  更偏向系统级开发

  在 CTF 中出现较少

---

## 链接器（Linker）

### 为什么需要链接器？

汇编器生成的并不是“完整程序”，
 而是一些**零散的机器指令块**。

**链接器**负责：

- 把这些指令拼在一起
- 补全程序入口
- 生成最终可执行文件

可以理解为：

> 🔗 **把“零件”组装成“整台机器”**

在 Linux 中，最常见的链接器是 `ld`。
