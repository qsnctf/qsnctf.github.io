# C 与 C++

C 和 C++ 关系很近，但 **定位、设计思想和能力差别挺大** 。可以把它们理解为：**C 是“面向过程的底层工具”，C++ 是“在 C 基础上发展出来的多范式语言”**。

- **C**：面向过程，贴近硬件，简单直接

- **C++**：在 C 基础上加入 **面向对象 + 泛型 + 现代特性** ，更适合大型工程

> **C 语言**诞生于 20 世纪 70 年代初，由贝尔实验室的 Dennis Ritchie 为了重写 UNIX 操作系统而设计，它在 B 语言的基础上发展而来，目标是在保证接近汇编语言效率的同时提供更好的可读性和可移植性。由于 C 语言结构简单、性能高、对硬件控制能力强，很快成为操作系统、编译器和各类系统软件的核心语言，并在之后通过 ANSI C 等标准化过程长期保持稳定。

> **C++** 起源于 20 世纪 80 年代，由同样在贝尔实验室工作的 Bjarne Stroustrup 在 C 语言基础上扩展而成，最初名为 “C with Classes”，旨在解决 C 语言在大型程序开发中抽象能力不足、维护成本高的问题。C++ 在保留 C 高性能和底层控制能力的同时，引入了面向对象、泛型编程和丰富的标准库，并通过持续的标准演进发展为一种既适合底层系统又能支撑大型复杂工程的多范式语言。

![](assets/无标题-2026-01-26-1054.png)

## 编程范式不同

### C是面向过程的

```C
int add(int a, int b) {
    return a + b;
}
```

### C++是多范式的

```c++
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }
};
```

>  C++ 可以像 C 一样写，但 C 不能用 C++ 的对象思想。

## 面向对象支持

C++ 支持：

- 类（class）
- 封装、继承、多态
- 构造函数 / 析构函数

```c++
class Person {
public:
    Person() { }
    ~Person() { }
};
```

> C：完全不支持这些，只能靠结构体 + 函数“硬模拟”。

##  类型系统

### C

- 类型检查 **较弱**
- `void*` 随便转

### C++

- 类型检查 **更严格**
- 引入 `bool`、`nullptr`
- 支持函数重载

```c++
int add(int a, int b);
double add(double a, double b);
```

## 内存管理方式

### C

```c
malloc();
free();
```

### C++

```C++
new;
delete;
```

并且 C++ 还有：

- 构造 / 析构自动管理
- **RAII**
- 智能指针（`unique_ptr`, `shared_ptr`）

 **C++ 更安全，C 更原始**

## 标准库差距巨大

### C

- 标准库很小（stdio.h、stdlib.h）
- 偏底层

### C++

- 超强标准库（STL）
  - `vector`
  - `map`
  - `unordered_map`
  - `algorithm`

```c++
vector<int> v = {1, 2, 3};
```

> C：要自己造轮子 

## 异常处理

**C**：靠返回值 / `errno`

**C++**：支持 `try / catch`

```c++
try {
    throw 1;
} catch(int e) {
}
```

## 兼容性

- **C++ 基本兼容 C**
- **C 不兼容 C++**

> `.c` 文件 ≠ `.cpp` 文件



## 使用场景对比

| 场景            | 更适合  |
| --------------- | ------- |
| 操作系统 / 内核 | C       |
| 嵌入式底层      | C       |
| 游戏引擎        | C++     |
| 大型工程        | C++     |
| 高性能库        | C / C++ |

> C 是“你必须自己负责一切的语言”
> C++ 是“给你强大工具，但也更复杂的语言”