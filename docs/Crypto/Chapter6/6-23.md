## 提公因数 p 构造简易方程求解

题目给出代码

```python
from Crypto.Util.number import *
from secret import flag

e = 65537
m = bytes_to_long(flag.encode())
p, q, r = getPrime(512), getPrime(512), getPrime(512)

n = p*q*r
c = pow(m, e, n)
print(c)
print(n)
print(p+q+r)
print(p*q+p*r)
```

转换成数学公式
$$
\begin{aligned}
&n\ =\ p\ *\ q\ *\ r\\
&t\ =\ p\ *\ q\ +\ p\ *\ r\ =\ p(q\ +\ r)\\
&ϕ(n)\ =\ (p\ -\ 1)(q\ -\ 1)(r\ -\ 1)
\end{aligned}
$$
我们可以清楚地看到，**p 是 n 和 t 的公共因子**

那 GCD(n, t) 会正好是 p 吗？会不会包含其他因子？
$$
\begin{aligned}
&GCD(pqr,p(q\ +\ r))\ =\ p\ *\ GCD(qr,q\ +\ r)
\end{aligned}
$$
由于 q 和 r 都是生成的 512 位随机大素数，它们互质，且它们的和 q+r 极大概率与它们的积 qr 互质

因此 GCD(qr, q+r) = 1

**结论：** 直接计算 GCD(n, t) 就能无痛提取出素数 p

对于 n=pqr，欧拉函数定义为：
$$
\begin{aligned}
&\phi(n)\ =\ (p-1)(q-1)(r-1)\\
&\phi(n)\ =\ (p-1)\ *\ [(q-1)(r-1)]\\\\
&n\ -\ t\ =\ pqr\ -\ pq\ - \ pr\\
&n\ -\ t\ =\ p(qr\ -\ q\ - \ r)\\
&(n\ -\ t)\ //\ p\ =\ (qr\ -\ q\ - \ r)\\
&(n\ -\ t)\ //\ p\ +\ 1\ =\ (qr\ -\ q\ - \ r)\ +\ 1\\\\
&qr\ -\ q\ - \ r\ +\ 1\ =\ q(r\ -\ 1)\ -\ 1(r\ -\ 1)\\
&q(r\ -\ 1)\ -\ 1(r\ -\ 1)\ =\ (q\ -\ 1)(r\ -\ 1)\\\\
&(n\ -\ t)\ //\ p\ +\ 1\ =\ (q\ -\ 1)(r\ -\ 1)\\
&\phi(n)\ =\ (p-1)\ *\ [(q-1)(r-1)]\\\\
\end{aligned}
$$
**观察公因数** 是 Crypto 选手的直觉。看到 n 和 t 有明显的公共结构（都含有 p），第一时间想到的就是 GCD

```python
from Crypto.Util.number import *

# ==========================================
# 题目信息与数学关系回顾
# ------------------------------------------
# 已知：
# n = p * q * r  (三素数 RSA)
# s = p + q + r  (此变量在本脚本中未被使用)
# t = p * q + p * r = p * (q + r)
# ==========================================

# 题目给出的长整数数据（省略部分以保持整洁）
c = 216719040256186298397028655750064798850... 
n = 894056034566447301955142597300391580123...
t = 157435908314881832180551915807491465031...

# [第一步]：提取公共素因子 p
# 数学原理：n = p*q*r，t = p*(q+r)
# 显然 p 是 n 和 t 的最大公约数
p = GCD(n, t)

# [第二步]：巧妙构造欧拉函数 phi(n)
# 目标：phi = (p-1) * (q-1) * (r-1)
# 
# 1. 括号右边推导：((n - t) // p + 1)
#    分子：n - t = pqr - (pq + pr) = pqr - pq - pr = p(qr - q - r)
#    除法：(n - t) // p = qr - q - r
#    加一：qr - q - r + 1
#    因式分解：q(r-1) - 1(r-1) = (q-1)(r-1)
#
# 2. 最终合并：
#    (p-1) * [(q-1)(r-1)] = phi(n)
phi = (p - 1) * ((n - t) // p + 1)

# [第三步]：常规 RSA 私钥计算
# 计算 e 在模 phi 下的乘法逆元 d
d = inverse(65537, phi)

# [第四步]：解密
# m = c^d mod n
m = pow(c, d, n)

# 将解密出的长整数转换为字节串（即明文 Flag）
print(long_to_bytes(m))
```

