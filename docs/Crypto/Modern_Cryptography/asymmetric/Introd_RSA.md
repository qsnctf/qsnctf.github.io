RSA 是一种基于数论的**非对称公钥密码算法**，可同时用于**加密**和**数字签名**，是现代密码学和互联网安全基础设施（如 TLS/SSL、HTTPS、PKI）的核心算法之一。其安全性建立在**大整数分解困难性**之上，即：将两个大素数相乘很容易，但反过来从其乘积还原出原始素数在计算上极其困难。

“RSA”这一名称取自三位发明者姓氏的首字母：**Rivest、Shamir、Adleman**。



## 1. RSA的历史

1976 年，美国密码学家**惠特菲尔德·迪菲（Whitfield Diffie）**和**马丁·赫尔曼（Martin Hellman）**发表了开创性的论文，首次提出了**公钥密码（非对称密码）**的概念，打破了“通信双方必须事先共享秘密密钥”的传统范式。

1977 年，麻省理工学院（MIT）的**罗纳德·李维斯特（Ron Rivest）**、**阿迪·萨莫尔（Adi Shamir）**和**伦纳德·阿德曼（Leonard Adleman）**共同提出了 RSA 算法。

在此之前的一年多时间里，三人一直在寻找一个**易于正向计算但难以逆向求解的单向函数**，以实现真正的公钥加密与数字签名。他们尝试了多种数学构造，包括：

- 基于背包问题的方案
- 基于置换多项式的方法
- 其他组合数学和数论构造

这些尝试均存在安全缺陷或可逆性问题，一度让他们怀疑目标是否可能实现。

据三位发明者回忆，关键突破出现在 1977 年逾越节期间。里维斯特在失眠时重新思考问题，最终意识到**大整数分解**可作为单向陷门函数的基础，并在清晨完成了论文的大部分数学框架。随后，他们正式提出了现在广为人知的 **RSA 算法**。

RSA 不仅支持加密，还天然支持**数字签名**，弥补了迪菲–赫尔曼体系中“缺乏可实现签名机制”的空白。

值得注意的是，英国政府通信总部（GCHQ）的数学家**克利福德·科克斯（Clifford Cocks）\**早在 \*\*1973 年\*\*就在内部文件中独立提出了一种\**与 RSA 等价的系统**，同样基于大素数乘积与模幂运算。

然而，由于：

- 当时计算机性能有限
- 实际部署成本极高
- 工作属于高度机密

该方案主要被视为理论性成果，从未在公开系统中使用。科克斯的工作直到 **1997 年**才被解密并公之于众，此后才被历史正式承认为“RSA 的先行发现”。

1997 年，研究人员提出了 **Kid-RSA（KRSA）**，这是一种**简化且不安全的教学版 RSA**，用于帮助学生理解：

- 公钥与私钥的关系
- 模幂运算
- 欧拉函数
- 大整数分解与安全性的关联

Kid-RSA 在教育中的地位类似于密码学中的 **Simplified DES（S-DES）**：
 它**不适用于真实安全通信**，但非常适合课堂演示与实验教学。

RSA 的提出具有里程碑意义：

- 奠定了现代互联网安全基础
- 支撑了 HTTPS、电子签名、数字证书和 PKI
- 推动了计算数论、复杂性理论和量子安全研究
- 促进了密码学从“军事机密”走向公开学术领域

尽管量子计算的发展可能在未来威胁 RSA，但目前它仍是全球最重要的公钥密码算法之一。



## 2. 基本原理

RSA的安全性建立在**大整数分解的困难性**之上。

- 将两个大素数相乘在计算上是非常容易的。
- 但要将它们的乘积（极大的数）重新分解为原始的素数，在现有的计算能力下（对于足够长的密钥，如2048位）几乎是不可能的。



## 3. 公钥与私钥的产生

RSA 密钥由**公钥（n, e）**和**私钥 d**组成。

### **步骤 1：选择素数**

选择两个**大且互异的素数** $p$ 和 $q$：

- 在现代系统中，通常选择**每个约 1024 比特**的素数；
- 这使得 $n = pq$ 约为 **2048 比特**（2048 位 RSA）；
- $p$ 和 $q$ 必须**随机且独立**地从极大的素数空间中选取；
- **$p$ 和 $q$ 必须严格保密。**

------

### **步骤 2：计算模数 $n$**

$$
n = p \cdot q
$$

- $n$ 是**公钥和私钥的共同模数**；
- $n$ 的比特长度通常被称为“RSA 密钥长度”；
- **$n$ 会公开发布。**

------

### **步骤 3：计算卡迈克尔函数 $\lambda(n)$**

令：
$$
\lambda(n) = \operatorname{lcm}(p-1,\, q-1)
$$
因为：

- $p, q$ 为素数；
- $\lambda(p)=p-1,\ \lambda(q)=q-1$；

所以：
$$
\lambda(n)=\operatorname{lcm}(p-1,q-1)
$$
可通过欧几里得算法计算，因为：
$$
\operatorname{lcm}(a,b)=\frac{|ab|}{\gcd(a,b)}
$$
**$\lambda(n)$ 必须保密。**

------

### **步骤 4：选择公钥指数 $e$**

选择整数 $e$，满足：
$$
1 < e < \lambda(n),\quad \gcd(e,\lambda(n)) = 1
$$
常见选择：

- **最常用：** $e = 2^{16}+1 = 65537$
  - 优点：运算快、结构简单、安全性良好
- 理论上最小可选值是 $e=3$，但在不安全填充下可能导致攻击，因此**很少使用**。

**$e$ 会作为公钥的一部分公开。**

------

### **步骤 5：计算私钥指数 $d$**

计算：
$$
d \equiv e^{-1} \pmod{\lambda(n)}
$$
即求解：
$$
de \equiv 1 \pmod{\lambda(n)}
$$
这等价于求解**贝祖等式**，可用**扩展欧几里得算法**高效计算。

- **$d$ 必须严格保密。**
- 一旦计算出 $d$，在理论上可以丢弃 $p,q,\lambda(n)$，但在高性能实现中通常保留它们。

------

### **关于欧拉函数与卡迈克尔函数的区别**

原始 RSA 论文使用的是：
$$
\varphi(n) = (p-1)(q-1)
$$
而现代实现更倾向使用：
$$
\lambda(n)=\operatorname{lcm}(p-1,q-1)
$$
原因：

- $\lambda(n) \mid \varphi(n)$，因此两者都能工作；
- 但用 $\varphi(n)$ 计算的 $d$ 可能比必要的大；
- 一些标准（如 FIPS 186-4）要求 $d < \lambda(n)$。

若得到过大的 $d$，可简单取：
$$
d := d \bmod \lambda(n)
$$
即可修正。

------

### **密钥生成方向的历史变化**

- **原始 RSA（1977）：**
   先选 $d$，再计算 $e$。
- **现代实现（如 PKCS#1）：**
   先选固定小 $e$，再计算 $d$。

原因：

- 小而固定的 $e$ 让**公钥运算更快**；
- $d$ 仍足够大，**不损害安全性**。

## 4.关键分发

设 Alice（接收方）和 Bob（发送方）使用 RSA：

- Alice 公开：**公钥 $(n,e)$**
- Alice 私有：**私钥 $d$**
- Bob 需要 Alice 的公钥才能加密或验证签名；
- **私钥永远不能被分发。**

公钥可通过**公开但可信的渠道**传输，如数字证书、PKI 或 CA。

## 5. 消息加密

Bob 想发送消息 $M$ 给 Alice：

1. 先用**填充方案**（如 OAEP）将 $M$ 转换为整数 $m$，满足：
   $$
   0 \le m < n
   $$

2. 计算密文：
   $$
   c \equiv m^e \pmod n
   $$

3. 将 $c$ 发送给 Alice。

此运算可用**快速模幂算法（平方乘算法）**高效完成。

> 说明：理论上存在少量固定点 $m$ 使得 $m^e \equiv m \pmod n$，但在正确填充下几乎不会影响安全性。

## 6. 消息解密

Alice 使用私钥 $d$ 计算：
$$
m \equiv c^d \pmod n
$$
再反转填充得到原始消息 $M$。

**重要安全原则：**
 若填充无效，Alice **必须直接丢弃消息，不给任何错误提示细节**，否则可能遭受“填充预言机攻击”。

## 7. 正确性证明

> RSA 的正确性源于数论：当 $ed\equiv1\pmod{\lambda(n)}$ 时，对任意整数 $m$ 都有 $(m^{e})^{d}\equiv m \pmod n$。该结论既可用费马小定理逐模证明，也可用欧拉定理或其卡迈克尔推广整体证明。

RSA 的正确性是指：
 对于任意整数 $m$，当公钥指数 $e$ 与私钥指数 $d$ 满足
$$
ed \equiv 1 \pmod{\lambda(n)}
$$
且 $n = pq$ 为两个不同素数的乘积时，始终有：
$$
(m^{e})^{d} \equiv m \pmod{n}.
$$
也就是说：**先加密再解密一定能还原原文（模 $n$ 意义下）**。

以下给出两种常见证明方式。

------

### **一、基于费马小定理的证明（接近原始 RSA 论文）**

#### **数学基础**

**费马小定理：**
 若 $p$ 为素数且 $p\nmid a$，则：
$$
a^{p-1} \equiv 1 \pmod{p}.
$$
在 RSA 中：
$$
n = pq,\qquad 
\lambda(n)=\operatorname{lcm}(p-1,q-1).
$$
由条件 $ed \equiv 1 \pmod{\lambda(n)}$，可写成：
$$
ed - 1 = h(p-1) = k(q-1)
$$
其中 $h,k$ 为非负整数。

------

#### **关键思路：逐模证明 + 中国剩余定理思想**

要证明：
$$
m^{ed} \equiv m \pmod{pq},
$$
只需分别证明：
$$
m^{ed} \equiv m \pmod{p}
\quad \text{且} \quad
m^{ed} \equiv m \pmod{q},
$$
因为对 $p$ 与 $q$ 都成立的同余式，必然对 $pq$ 成立（中国剩余定理的基本思想）。

------

#### **对模 $p$ 的证明**

分两种情况讨论：

##### **情况 1：$m \equiv 0 \pmod{p}$**

则 $m$ 是 $p$ 的倍数，因而 $m^{ed}$ 也是 $p$ 的倍数：
$$
m^{ed} \equiv 0 \equiv m \pmod{p}.
$$
结论成立。

------

##### **情况 2：$m \not\equiv 0 \pmod{p}$**

利用 $ed-1 = h(p-1)$，有：
$$
\begin{aligned}
m^{ed}
&= m^{ed-1}\, m \\
&= m^{h(p-1)}\, m \\
&= (m^{p-1})^{h} m \\
&\equiv 1^{h} m \pmod{p} \quad (\text{由费马小定理})\\
&\equiv m \pmod{p}.
\end{aligned}
$$
因此对所有 $m$：
$$
m^{ed} \equiv m \pmod{p}.
$$

------

#### **对模 $q$ 的证明**

同样分两种情况：

- 若 $m \equiv 0 \pmod{q}$，显然有 $m^{ed} \equiv m \pmod{q}$；
- 若 $m \not\equiv 0 \pmod{q}$，利用 $ed-1 = k(q-1)$ 与费马小定理，可得：

$$
m^{ed} \equiv m \pmod{q}.
$$

------

#### **综合结论**

因为：
$$
m^{ed} \equiv m \pmod{p}
\quad \text{且} \quad
m^{ed} \equiv m \pmod{q},
$$
由中国剩余定理可得：
$$
(m^{e})^{d} = m^{ed} \equiv m \pmod{pq}.
$$
这完成了 RSA 正确性的证明。

------

#### **重要注记**

1. **不能直接对模 $pq$ 应用费马小定理。**
    因为 $pq$ 不是素数，费马小定理只适用于素数模。

2. **为何现代实现可用更弱条件？**
    只要满足
   $$
   ed \equiv 1 \pmod{\lambda(pq)},
   $$
   上述证明仍然成立；并不需要更强的
   $$
   ed \equiv 1 \pmod{(p-1)(q-1)}.
   $$

3. **与中国剩余定理的关系。**
    上述“分别对 $p$ 与 $q$ 证明，再合并结论”的方法，本质上是中国剩余定理思想的一部分。

------

### **二、基于欧拉定理的证明（现代标准版本）**

#### **数学基础：欧拉定理**

若 $\gcd(m,n)=1$，则：
$$
m^{\varphi(n)} \equiv 1 \pmod{n},
$$
其中：
$$
\varphi(n) = (p-1)(q-1).
$$

------

#### **证明过程**

设：
$$
ed = 1 + h\varphi(n)
$$
则当 $\gcd(m,n)=1$ 时：
$$
\begin{aligned}
m^{ed}
&= m^{1 + h\varphi(n)} \\
&= m\,(m^{\varphi(n)})^{h} \\
&\equiv m\cdot 1^{h} \pmod{n} \\
&\equiv m \pmod{n}.
\end{aligned}
$$
这就证明了：
$$
m^{ed} \equiv m \pmod{n}.
$$

------

#### **更一般的情形：使用卡迈克尔函数**

若仅满足：
$$
ed \equiv 1 \pmod{\lambda(n)},
$$
则可使用 Carmichael 定理（欧拉定理的推广）：
$$
m^{\lambda(n)} \equiv 1 \pmod{n}
\quad (\gcd(m,n)=1),
$$
同样可推出：
$$
m^{ed} \equiv m \pmod{n}.
$$

------

#### **当 $m$ 与 $n$ 不互质时怎么办？**

这种情况极少发生（概率约为 $1/p + 1/q - 1/(pq)$），但即使发生，仍然有：

- 若 $m \equiv 0 \pmod{p}$，则 $m^{ed} \equiv m \pmod{p}$；
- 若 $m \equiv 0 \pmod{q}$，则 $m^{ed} \equiv m \pmod{q}$；

因此**回退到第一种费马小定理证明**即可覆盖这些边界情况。



## 步骤操作

| **步骤** | **操作** | **公式**                   | **涉及参数**  |
| -- | -- | -- | - |
| **准备** | 生成密钥 | $n=pq, \phi(n)=(p-1)(q-1)$ | $p, q$ (销毁) |
| **加密** | 使用公钥 | $C = M^e \pmod{n}$         | $n, e$        |
| **解密** | 使用私钥 | $M = C^d \pmod{n}$         | $n, d$        |



## 示例1

### 1. 密钥生成步骤

1. **选择素数**：令 $p = 3, q = 11$。
2. **计算模数**：$n = p \times q = 33$。
3. **计算欧拉函数**：$\phi(n) = (3-1) \times (11-1) = 2 \times 10 = 20$。
4. **选择公钥指数 $e$**：我们需要一个与 20 互质的数，选 $e = 3$。
5. **计算私钥指数 $d$**：需满足 $3d \equiv 1 \pmod{20}$。
   - 通过试算：$3 \times 7 = 21$，而 $21 \div 20$ 余 $1$。
   - 所以 **$d = 7$**。

**结果：**

- **公钥**：$(n=33, e=3)$
- **私钥**：$(n=33, d=7)$

### 2. 加密演示

假设我们要发送的消息明文 **$M = 5$**：

$$C = M^e \pmod{n}$$

$$C = 5^3 \pmod{33} = 125 \pmod{33}$$

计算 $125 \div 33 = 3$ 余 $26$，所以 **密文 $C = 26$**。

### 3. 解密演示

接收方收到密文 $26$，使用私钥 $d=7$ 进行还原：

$$M = C^d \pmod{n}$$

$$M = 26^7 \pmod{33}$$

为了计算方便，我们可以拆解幂运算：

- $26^1 \equiv 26 \equiv -7 \pmod{33}$
- $26^2 \equiv (-7)^2 = 49 \equiv 16 \pmod{33}$
- $26^4 \equiv 16^2 = 256 \equiv 25 \pmod{33}$
- $26^7 = 26^4 \times 26^2 \times 26^1 \equiv 25 \times 16 \times (-7) \pmod{33}$
- 计算得出结果为 **$5$**。

**明文还原成功！**

## 示例2

取：
$$
p=61,\quad q=53
$$
则：
$$
n = 61 \cdot 53 = 3233
$$
计算：
$$
\lambda(n)=\operatorname{lcm}(60,52)=780
$$
选：
$$
e=17
$$
求逆得到：
$$
d=413
$$
**公钥：** $(n=3233, e=17)$
**私钥：** $d=413$

加密 $m=65$：
$$
c = 65^{17} \bmod 3233 = 2790
$$
解密：
$$
m = 2790^{413} \bmod 3233 = 65
$$

## 基于中国剩余定理（CRT）的加速

为提升解密效率，实际私钥通常还包含：
$$
d_p = d \bmod (p-1),\quad  
d_q = d \bmod (q-1),\quad  
q^{-1} \bmod p
$$
先分别计算：
$$
m_1 = c^{d_p} \bmod p,\quad  
m_2 = c^{d_q} \bmod q
$$
再用中国剩余定理合成得到最终 $m$。

该方法可使解密速度提升约 **4 倍**。



## RSA数字签名

### **签名**

Alice 对消息 $M$：

1. 计算哈希：
   $$
   h = \text{hash}(M)
   $$

2. 生成签名：
   $$
   s = h^d \bmod n
   $$

3. 发送 $(M, s)$ 给 Bob。

------

### **验证**

Bob 计算：
$$
h = \text{hash}(M)
$$
并检查：
$$
s^e \stackrel{?}{\equiv} h \pmod n
$$
若成立，则：

- 消息确实来自 Alice；
- 消息未被篡改。

数学依据：
$$
s^e = (h^d)^e = h^{de} \equiv h \pmod n
$$

------

### **为什么必须先做哈希？**

若直接签名原始消息 $m$，则存在可乘法伪造的漏洞：

- 可伪造 $(m_1 m_2, s_1 s_2)$；
- 可对 $m=1$ 伪造签名 $s=1$。

因此**现代 RSA 签名必须先哈希，再签名**（如 RSA-PSS）。