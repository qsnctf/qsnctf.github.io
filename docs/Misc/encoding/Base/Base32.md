Base32与Base64类似，都是 **二进制数据文本化** 的编码方式，常见字符集为 **`A–Z` 和 `2–7`**，并使用 **`=`** 作填充。它的目的是便于在只适合传文本的场景中传输/存储二进制数据。与 Base64 一样：**Base32 不是加密，只是编码**。

## Base32 的原理

### (1) 核心思想

> 5 字节 → 8 个字符（因为 40 bit → 8×5 bit）

- 原始数据按 **1字节**（8 bit）输入。
- Base32 把数据按 **5 bit** 为一个编码单元（因为 $2^5=32$）。
- 因为 **5 字节 = 40 bit**，刚好能切成 **8 组 5 bit**，输出 8 个字符。
- 每个 5 bit 值范围是 **0~31**，用 32 个字符映射即可。

### (2) 具体流程（编码）

假设有 5 个字节 `b1 b2 b3 b4 b5`：

1. 拼成 40 bit：`b1|b2|b3|b4|b5`
2. 切成 8 段：`s1(5) s2(5) ... s8(5)`
3. 每段转成十进制索引（0~31）
4. 查 Base32 字母表映射成字符输出

> 小提示：实际实现会做“比特缓冲区”（bit buffer），不断塞入 8bit、吐出 5bit。

### (3) 为什么会有 `=`（Padding）

当输入字节数不是 5 的倍数时，最后一组不够 40 bit，需要补齐让输出长度规整（常见做法是让输出长度是 8 的倍数）：

- 先在末尾补 0 bit 到能整切 5 bit
- 再用 `=` 替换那些“完全由补 0 推导出来”的输出字符，用来告诉解码器末尾哪些是填充

### (4) 解码过程（反向还原）

解码就是反过来：

1. 每个 Base32 字符查表得到 0~31 的 5-bit 值（忽略末尾 `=`）
2. 拼接成 bit 流
3. 每 8 bit 还原成字节输出
4. 根据 `=` 的数量丢弃补出来的末尾字节

### (5) 空间开销与“为什么是 32”

- Base32：**5 字节 → 8 字符**，若按 ASCII/UTF-8 存储，体积变为 `8/5 = 1.6`，膨胀约 **60%**（比 Base64 的 ~33% 更大）。
- 选择 32 是因为 $2^5=32$，用 5 bit 正好表示 32 种符号，并且字符集更“保守”（适合大小写不敏感或易混淆场景的变体也很多）。

## RFC 4648 标准的 Base32 索引表（常用）

| 数值 | 字符 | 数值 | 字符 | 数值 | 字符 | 数值 | 字符 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  A   |  8   |  I   |  16  |  Q   |  24  |  Y   |
|  1   |  B   |  9   |  J   |  17  |  R   |  25  |  Z   |
|  2   |  C   |  10  |  K   |  18  |  S   |  26  |  2   |
|  3   |  D   |  11  |  L   |  19  |  T   |  27  |  3   |
|  4   |  E   |  12  |  M   |  20  |  U   |  28  |  4   |
|  5   |  F   |  13  |  N   |  21  |  V   |  29  |  5   |
|  6   |  G   |  14  |  O   |  22  |  W   |  30  |  6   |
|  7   |  H   |  15  |  P   |  23  |  X   |  31  |  7   |

索引 `0~31` 对应字符：

```
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 2 3 4 5 6 7
```

（即：`0->A ... 25->Z, 26->2 ... 31->7`）

## 例子

### 例1. 无需补 `=`

以字符串 **`"foo"`** 为例（3 字节）：

1. ASCII 十进制：`f o o` → `102 111 111`
2. 二进制：
    `01100110 01101111 01101111`
3. 按 5 bit 切分（不够的先在末尾补 0）：
    `01100 11001 10111 10111 01111 00000`
4. `01100`转`10进制`为12，`11001`为25， `10111`为23 ，`10111`同样是23， `01111`为15， `00000`是0
5.  对应索引：`12 25 23 23 15 0`
    查表：`M Z X X P A`
6. 因为原文只有 3 字节，按 Base32 规范常输出到 8 的倍数，所以结果会补 `=` 成 8 长度：
    最终：`"foo"` → `MZXW6===`（这是经典结果，你在很多工具里都能对上）

> 你会发现：Base32 经常让输出长度凑到 8 的倍数（因此 `=` 也更常见）。

### 例2. 补 `=`（演示更直观）

以 **`"f"`**（1 字节）为例：

- `f` = 102 = `01100110`
- 取 5 bit：`01100`（12 → `M`），剩余 `110` 需要补 0 组成 5 bit：`11000`（24 → `Y`）
- 这时有效字符是 `MY`，剩下的为了凑成 8 个字符，用 `=` 补齐：
   最终：`"f"` → `MY======`

### 例3. 解码（把 `MY======` 解回 `f`）

1. `M`→12→`01100`，`Y`→24→`11000`
2. 拼 bits：`01100 11000` → `0110011000`
3. 每 8 bit 取一个字节：`01100110` = 102 = `'f'`
4. 后面多出来的 `00` 以及 `=` 对应的填充丢弃即可
    最终：`MY======` → `f`

## 练习题

题目地址：[NO.0966 - Base32](https://www.qsnctf.com/#/main/driving-range?page=1&keyword=NO.0966){ .md-button .md-button--primary target="_blank" rel="noopener"}

![](attachments/image-20251202233734997.png)

- 题目名称：Base32
- 题目难度：1
- 题目ID：NO.0966

## 在线工具

[在线Base32解码工具](https://tools.qsnctf.com/#//misc/base){ .md-button .md-button--primary target="_blank" rel="noopener"}

