## Scanf 堆溢出覆盖相邻堆块

首先看源代码拿到 flag 的条件

```c
void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flag for you :(\n");
        fflush(stdout);
    }
}
```

用户输入的函数

这里的函数 `scanf` 是**漏洞利用的关键**

由于 `scanf`  **缺乏边界检查**，它可以溢出 `input_data` 缓冲区，让我们能够覆盖相邻的内存位置，包括 `safe_var`

```c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
```

开头会打印出两个堆块的地址，相减得到偏移 32

![](https://pic1.imgdb.cn/item/6885e8bf58cb8da5c8e48c68.png)

生成大于 32 个的随机字符串输入拿到 flag

![](https://pic1.imgdb.cn/item/6885e8fa58cb8da5c8e48d6f.png)
