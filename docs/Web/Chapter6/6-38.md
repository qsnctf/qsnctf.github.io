## GC UAF 提权

GC（Garbage Collection）机制

- PHP 的 GC 机制主要处理循环引用的内存释放
- 当对象之间存在循环引用时，正常的引用计数无法释放这些对象，GC 会检测并回收
- 在 PHP 5.3+ 引入的 **周期性垃圾收集器**（Cycle Collector）处理这类问题

**第一步：制造 UAF 场景**

通过创建一组存在循环引用的对象，比如：

```php
class A {
    public $ref;
}
$a = new A();
$b = new A();
$a->ref = $b;
$b->ref = $a;
```

然后取消引用：

```php
unset($a, $b);
```

这时候，两个对象形成的循环引用会被放入 GC roots 中等待清理

当 GC 清理这些对象时，如果其中某个对象的 `__destruct()` 方法访问了另一个已被释放的对象，就会触发 UAF

**第二步：布置恶意的析构方法**

在某个对象的 `__destruct()` 方法中调用 **动态方法或魔术方法**，并试图控制执行流程：

```php
class Exploit {
    function __destruct() {
        global $evil_payload;
        call_user_func($evil_payload);
    }
}
```

在 GC 回收阶段，该方法会被调用

**第三步：内存重用 & 漏洞触发**

因为 PHP 在释放内存后并不会立即清零，下次分配可能会复用该内存块

攻击者伪造新的对象结构或函数调用结构，劫持执行流，典型的方式包括：

- 伪造  `zend_execute_data`  结构
- 控制  `call_user_func()`  的函数指针
- 伪造  `zval`  指向一个特定的函数调用结构

**第四步：构造绕过 Payload，实现命令执行**

通过 UAF 劫持执行流后，攻击者构造出一个函数调用链，**最终跳转到原本被禁用的函数（如 system）所在的位置**，并执行命令

```php
$func = "system"; // 被 disable_functions 禁用了
$evil_payload = [$func, "whoami"]; // 经过 UAF 执行这段
```

PHP 会认为是正常的回调函数，而绕过  `disable_functions`  的检查

蚁剑梭哈

![](https://pic1.imgdb.cn/item/6881a6c458cb8da5c8d35952.png)
