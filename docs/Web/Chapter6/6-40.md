## Backtrace UAF 提权

PHP 的 `debug_backtrace()`  和 `Exception::getTrace()` 会在运行时生成一个调用栈（trace），包含函数、文件、行号、参数等

这个调用栈实际上是 **zval 结构体组成的数组**，包括函数指针、类名、参数指针等

关键点是：在构造  `backtrace` 时，PHP 会将当前的执行栈压入临时内存

**💡 1. 构造 backtrace 引发临时结构体分配**

```php
function trigger() {
    debug_backtrace();
}
```

当调用 `debug_backtrace()`，PHP 会构造一个 `zend_execute_data` 结构体的快照，用于保存当前调用栈，这里面包含很多指针，如：

- 函数名（function_name）
- 类名（class_name）
- 参数（zval 指针）
- zend_function 指针（可能有执行函数 handler）

**💡 2. 引发某些对象的释放（free）**

利用某些语言特性或者对象析构等方式，让一些结构体**释放掉但仍保留引用**

```php
class A {
    public function __destruct() {
        global $a;
        unset($a); // 引发析构
        debug_backtrace(); // 调用时释放对象导致悬空引用
    }
}
```

**💡 3. 重新分配释放后的内存（填充 UAF）**

接下来攻击者会分配**用户可控的数据**，例如字符串、数组、对象等，来**填充已经释放的内存区域**

由于 PHP 使用堆内存管理机制（Zend Memory Manager），释放后的内存会被优先复用

```php
$fake_func = str_repeat("\x41", 100); // 用 'A' 重写释放的结构体
```

攻击者可以控制一些偏移处的内容来伪造 `zend_function`、`zend_execute_data` 等结构体，从而控制执行流

**💡 4. 利用调用堆栈中的函数指针完成控制流劫持**

在调用 backtrace 的时候，PHP 会尝试读取 `zend_function` 并调用其中的 `internal_function.handler`

如果这个结构体是伪造的、用户可控的，那这个 handler 就变成了任意地址！

攻击者就可以跳转到：

- libc 的 `system()` 函数
- 已知地址的 shellcode
- php-fpm 或 apache 中的其他函数地址（如 `execvp`, `popen`, 等）

```php
class Trigger {
    function __destruct() {
        debug_backtrace(); // 引发栈分配 + UAF
    }
}

$a = new Trigger();
unset($a); // 引发 __destruct

// 填充已释放内存
$payload = str_repeat("\x00", 0x100); // 控制结构体内容

// 此时 handler 被劫持，跳到 system("/readflag") 等地址
```

蚁剑插件直接梭哈

![](https://pic1.imgdb.cn/item/6881cf6f58cb8da5c8d46bf9.png)
